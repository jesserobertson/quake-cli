{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"quake-cli","text":"<p>A modern Python library for querying earthquake data from the GeoNet API</p>"},{"location":"#features","title":"Features","text":"<ul> <li>\ud83c\udf0d GeoNet API Integration - Query real-time earthquake data from New Zealand's GeoNet service</li> <li>\u26a1 Async Performance - Fast async HTTP client with automatic retries and error handling</li> <li>\ud83d\udd0d Flexible Filtering - Filter earthquakes by magnitude, MMI, location, and time</li> <li>\ud83d\udcca Type-Safe Data Models - Pydantic models for reliable earthquake data structures</li> <li>\ud83d\udd04 Result-Based Error Handling - Functional error handling with composable Result types</li> <li>\ud83d\ude80 Modern Python 3.12+ - Uses latest Python features with comprehensive type hints</li> <li>\ud83d\udcd6 Tested Examples - All documentation examples are automatically tested for accuracy</li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":""},{"location":"#installation","title":"Installation","text":"<pre><code>pip install quake_cli\n</code></pre>"},{"location":"#basic-usage","title":"Basic Usage","text":"<pre><code>import asyncio\nfrom quake_cli.client import GeoNetClient\nfrom logerr import Ok, Err\n\nasync def get_earthquakes():\n    async with GeoNetClient() as client:\n        # Get recent earthquakes\n        result = await client.get_quakes(limit=5)\n\n        match result:\n            case Ok(response):\n                for quake in response.features:\n                    props = quake.properties\n                    print(f\"M{props.magnitude:.1f} at {props.locality}\")\n            case Err(error):\n                print(f\"Error: {error}\")\n\nasyncio.run(get_earthquakes())\n</code></pre> <p>Example Output: <pre><code>M5.2 at 20 km north-east of Seddon\nM4.8 at 15 km south of Kaikoura\nM3.9 at 25 km west of Wellington\nM4.1 at 10 km east of Christchurch\nM3.7 at 30 km north of Dunedin\n</code></pre></p>"},{"location":"#filtering-and-search","title":"Filtering and Search","text":"<pre><code>import asyncio\nfrom quake_cli.client import GeoNetClient\nfrom logerr import Ok, Err\n\nasync def filter_earthquakes():\n    async with GeoNetClient() as client:\n        # Filter by magnitude\n        result = await client.search_quakes(min_magnitude=4.0, limit=3)\n\n        match result:\n            case Ok(response):\n                print(f\"Found {response.count} large earthquakes\")\n                for quake in response.features:\n                    props = quake.properties\n                    print(f\"M{props.magnitude:.1f} - {props.locality}\")\n            case Err(error):\n                print(f\"Error: {error}\")\n\nasyncio.run(filter_earthquakes())\n</code></pre> <p>Example Output: <pre><code>Found 15 large earthquakes\nM5.2 - 20 km north-east of Seddon\nM4.8 - 15 km south of Kaikoura\nM4.1 - 10 km east of Christchurch\n</code></pre></p>"},{"location":"#next-steps","title":"Next Steps","text":"<ul> <li>Quick Start Guide - Get up and running in minutes</li> <li>API Reference - Complete documentation with examples</li> <li>Data Models - Understanding earthquake data structures</li> </ul>"},{"location":"#geonet-api","title":"GeoNet API","text":"<p>This tool queries earthquake data from GeoNet, New Zealand's geological hazard information system. GeoNet provides real-time earthquake monitoring and data for New Zealand and surrounding areas.</p> <p>Data Attribution: Earthquake data provided by GeoNet (https://www.geonet.org.nz/)</p>"},{"location":"#support","title":"Support","text":"<ul> <li>GitHub Repository: jesserobertson/quake-cli</li> <li>Issues: GitHub Issues</li> <li>PyPI Package: quake_cli</li> </ul>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the MIT License.</p>"},{"location":"examples/","title":"Examples","text":"<p>This page showcases examples from the quake-cli codebase. All examples shown here are automatically tested as part of our test suite to ensure they remain current and functional.</p>"},{"location":"examples/#data-models-examples","title":"Data Models Examples","text":""},{"location":"examples/#working-with-earthquake-geometry","title":"Working with Earthquake Geometry","text":"<pre><code>from quake_cli.models import QuakeGeometry\n\n# Create earthquake geometry\ngeom = QuakeGeometry(type=\"Point\", coordinates=[174.123, -41.456, 5.2])\n\n# Access coordinates\nprint(f\"Longitude: {geom.longitude}\")  # 174.123\nprint(f\"Latitude: {geom.latitude}\")    # -41.456\nprint(f\"Depth: {geom.depth}\")          # 5.2\n\n# 2D coordinates (no depth)\ngeom_2d = QuakeGeometry(type=\"Point\", coordinates=[174.123, -41.456])\nprint(f\"Depth: {geom_2d.depth}\")       # None\n</code></pre>"},{"location":"examples/#filtering-earthquake-data","title":"Filtering Earthquake Data","text":"<pre><code>from datetime import datetime\nfrom quake_cli.models import QuakeProperties, QuakeGeometry, QuakeFeature, QuakeResponse\n\n# Create sample earthquake data\nprops1 = QuakeProperties(\n    publicID=\"quake1\",\n    time=datetime(2023, 1, 1),\n    depth=5.0,\n    magnitude=3.0,\n    locality=\"Place1\",\n    quality=\"best\"\n)\nprops2 = QuakeProperties(\n    publicID=\"quake2\",\n    time=datetime(2023, 1, 2),\n    depth=10.0,\n    magnitude=5.0,\n    locality=\"Place2\",\n    quality=\"best\"\n)\n\ngeom = QuakeGeometry(type=\"Point\", coordinates=[174.0, -41.0])\nfeatures = [\n    QuakeFeature(type=\"Feature\", properties=props1, geometry=geom),\n    QuakeFeature(type=\"Feature\", properties=props2, geometry=geom)\n]\nresponse = QuakeResponse(type=\"FeatureCollection\", features=features)\n\n# Filter by magnitude\nlarge_quakes = response.filter_by_magnitude(min_mag=4.0)\nprint(f\"Found {len(large_quakes)} large earthquakes\")  # 1\n\n# Find specific earthquake\nfound = response.get_by_id(\"quake1\")\nif found:\n    print(f\"Found: {found.properties.locality}\")  # Place1\n</code></pre>"},{"location":"examples/#working-with-mmi-modified-mercalli-intensity","title":"Working with MMI (Modified Mercalli Intensity)","text":"<pre><code>from datetime import datetime\nfrom quake_cli.models import QuakeProperties, QuakeGeometry, QuakeFeature, QuakeResponse\n\n# Create earthquakes with MMI data\nprops1 = QuakeProperties(\n    publicID=\"quake1\",\n    time=datetime(2023, 1, 1),\n    depth=5.0,\n    magnitude=3.0,\n    locality=\"Place1\",\n    quality=\"best\",\n    mmi=2\n)\nprops2 = QuakeProperties(\n    publicID=\"quake2\",\n    time=datetime(2023, 1, 2),\n    depth=10.0,\n    magnitude=5.0,\n    locality=\"Place2\",\n    quality=\"best\",\n    mmi=5\n)\n\ngeom = QuakeGeometry(type=\"Point\", coordinates=[174.0, -41.0])\nfeatures = [\n    QuakeFeature(type=\"Feature\", properties=props1, geometry=geom),\n    QuakeFeature(type=\"Feature\", properties=props2, geometry=geom)\n]\nresponse = QuakeResponse(type=\"FeatureCollection\", features=features)\n\n# Filter by MMI intensity\nsignificant = response.filter_by_mmi(min_mmi=3)\nprint(f\"Found {len(significant)} significant earthquakes\")  # 1\nprint(f\"MMI: {significant[0].properties.MMI}\")  # 5\n</code></pre>"},{"location":"examples/#cli-utilities-examples","title":"CLI Utilities Examples","text":""},{"location":"examples/#formatting-dates","title":"Formatting Dates","text":"<pre><code>from datetime import datetime\nfrom quake_cli.cli import format_datetime\n\n# Format earthquake timestamps\ndt = datetime(2023, 12, 25, 14, 30, 45)\nformatted = format_datetime(dt)\nprint(formatted)  # \"2023-12-25 14:30:45\"\n\n# New Year example\ndt2 = datetime(2024, 1, 1, 0, 0, 0)\nformatted2 = format_datetime(dt2)\nprint(formatted2)  # \"2024-01-01 00:00:00\"\n</code></pre>"},{"location":"examples/#error-handling-examples","title":"Error Handling Examples","text":""},{"location":"examples/#converting-exceptions-to-results","title":"Converting Exceptions to Results","text":"<pre><code>from quake_cli.result import handle_api_error\n\n# Handle API errors functionally\nerror = ValueError(\"Invalid input\")\nresult = handle_api_error(error)\n\n# Check if it's an error\nprint(result.is_err())        # True\nprint(result.unwrap_err())    # \"Invalid input\"\n</code></pre>"},{"location":"examples/#response-analysis-examples","title":"Response Analysis Examples","text":""},{"location":"examples/#checking-response-status","title":"Checking Response Status","text":"<pre><code>from quake_cli.models import QuakeResponse\n\n# Empty response\nempty_response = QuakeResponse(type=\"FeatureCollection\", features=[])\nprint(f\"Count: {empty_response.count}\")      # 0\nprint(f\"Empty: {empty_response.is_empty}\")   # True\n\n# Response with data (using the earthquake data from above)\nfilled_response = QuakeResponse(type=\"FeatureCollection\", features=features)\nprint(f\"Count: {filled_response.count}\")     # 2\nprint(f\"Empty: {filled_response.is_empty}\")  # False\n</code></pre>"},{"location":"examples/#testing-the-examples","title":"Testing the Examples","text":"<p>All examples on this page are automatically tested. You can run the tests yourself:</p> <pre><code># Run all doctests\npixi run test unit\n\n# Run doctests for specific modules\npixi run python -m doctest quake_cli/models.py -v\npixi run python -m doctest quake_cli/cli.py -v\npixi run python -m doctest quake_cli/result.py -v\n\n# Run pytest with doctest support\npixi run python -m pytest --doctest-modules quake_cli/ -v\n</code></pre> <p>This ensures that:</p> <ul> <li>\u2705 All examples remain functional as the code evolves</li> <li>\u2705 Documentation stays synchronized with the codebase</li> <li>\u2705 Users can trust that examples will work as shown</li> <li>\u2705 Breaking changes to public APIs are caught immediately</li> </ul>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#requirements","title":"Requirements","text":"<ul> <li>Python 3.12+</li> </ul>"},{"location":"installation/#install-from-pypi","title":"Install from PyPI","text":"<p>The recommended way to install quake-cli is from PyPI using pip:</p> <pre><code>pip install quake_cli\n</code></pre>"},{"location":"installation/#optional-dependencies","title":"Optional Dependencies","text":"<p>quake-cli supports several optional dependencies for additional functionality:</p>"},{"location":"installation/#development-dependencies","title":"Development Dependencies","text":"<p>If you want to contribute to the project or run tests:</p> <pre><code>pip install quake_cli[dev]\n</code></pre>"},{"location":"installation/#documentation-dependencies","title":"Documentation Dependencies","text":"<p>To build documentation locally:</p> <pre><code>pip install quake_cli[docs]\n</code></pre>"},{"location":"installation/#all-dependencies","title":"All Dependencies","text":"<p>To install all optional dependencies:</p> <pre><code>pip install quake_cli[all]\n</code></pre>"},{"location":"installation/#development-installation","title":"Development Installation","text":"<p>If you want to contribute to quake-cli, you can install it in development mode:</p>"},{"location":"installation/#prerequisites","title":"Prerequisites","text":"<ol> <li>Install pixi package manager</li> <li>Clone the repository:</li> </ol> <pre><code>git clone https://github.com/jesserobertson/quake-cli.git\ncd quake-cli\n</code></pre>"},{"location":"installation/#setup-development-environment","title":"Setup Development Environment","text":"<pre><code># Install dependencies\npixi install\n\n# Set up development environment (pre-commit hooks, etc.)\npixi run dev setup\n\n# Run tests to verify installation\npixi run test unit\n</code></pre>"},{"location":"installation/#verify-installation","title":"Verify Installation","text":"<p>To verify that quake-cli is installed correctly:</p> <pre><code>import quake_cli\nprint(quake_cli.__version__)\n</code></pre>"},{"location":"installation/#troubleshooting","title":"Troubleshooting","text":""},{"location":"installation/#common-issues","title":"Common Issues","text":"<ol> <li> <p>Import Error: Make sure you've installed quake_cli in the correct Python environment.</p> </li> <li> <p>Version Conflicts: Try installing in a fresh virtual environment:    <pre><code>python -m venv venv\nsource venv/bin/activate  # On Windows: venv\\Scripts\\activate\npip install quake_cli\n</code></pre></p> </li> </ol>"},{"location":"installation/#getting-help","title":"Getting Help","text":"<p>If you encounter any issues during installation:</p> <ol> <li>Check the Issue Tracker</li> <li>Search for existing solutions</li> <li>Create a new issue if needed</li> </ol>"},{"location":"quickstart/","title":"Quick Start","text":"<p>Get up and running with the quake-cli Python library in minutes. This guide focuses on using quake-cli as a library in your Python applications.</p>"},{"location":"quickstart/#installation","title":"Installation","text":"<pre><code>pip install quake_cli\n</code></pre>"},{"location":"quickstart/#your-first-earthquake-query","title":"Your First Earthquake Query","text":"<p>Let's start with a simple example to fetch recent earthquakes:</p> <pre><code>import asyncio\nfrom quake_cli.client import GeoNetClient\nfrom logerr import Ok, Err\n\nasync def get_recent_earthquakes():\n    \"\"\"Fetch and display recent earthquakes.\"\"\"\n    async with GeoNetClient() as client:\n        # Get recent earthquakes\n        result = await client.get_quakes(limit=5)\n\n        match result:\n            case Ok(response):\n                print(f\"Found {response.count} earthquakes:\")\n                for quake in response.features:\n                    props = quake.properties\n                    print(f\"  \u2022 M{props.magnitude:.1f} at {props.locality}\")\n                    print(f\"    Time: {props.time.strftime('%Y-%m-%d %H:%M:%S')}\")\n                    print(f\"    Depth: {props.depth:.1f} km\")\n                    print()\n            case Err(error):\n                print(f\"Error fetching earthquakes: {error}\")\n\n# Run the example\nasyncio.run(get_recent_earthquakes())\n</code></pre>"},{"location":"quickstart/#working-with-earthquake-data","title":"Working with Earthquake Data","text":"<p>The library provides rich Pydantic models for type-safe earthquake data:</p> <pre><code>import asyncio\nfrom quake_cli.client import GeoNetClient\nfrom logerr import Ok, Err\n\nasync def explore_earthquake_data():\n    \"\"\"Explore the structure of earthquake data.\"\"\"\n    async with GeoNetClient() as client:\n        result = await client.get_quakes(limit=1)\n\n        match result:\n            case Ok(response):\n                if not response.is_empty:\n                    quake = response.features[0]\n\n                    # Access earthquake properties\n                    props = quake.properties\n                    print(f\"Earthquake ID: {props.publicID}\")\n                    print(f\"Magnitude: {props.magnitude}\")\n                    print(f\"Depth: {props.depth} km\")\n                    print(f\"Location: {props.locality}\")\n                    print(f\"Quality: {props.quality}\")\n                    if props.MMI:\n                        print(f\"MMI: {props.MMI}\")\n\n                    # Access geometry data\n                    geom = quake.geometry\n                    print(f\"Coordinates: {geom.latitude:.4f}, {geom.longitude:.4f}\")\n                    if geom.depth:\n                        print(f\"Geometry depth: {geom.depth} km\")\n\n            case Err(error):\n                print(f\"Error: {error}\")\n\nasyncio.run(explore_earthquake_data())\n</code></pre>"},{"location":"quickstart/#filtering-earthquakes","title":"Filtering Earthquakes","text":"<p>Filter earthquakes by magnitude, MMI, or other criteria:</p> <pre><code>import asyncio\nfrom quake_cli.client import GeoNetClient\nfrom logerr import Ok, Err\n\nasync def filter_earthquakes():\n    \"\"\"Filter earthquakes by various criteria.\"\"\"\n    async with GeoNetClient() as client:\n        # Server-side MMI filtering\n        print(\"=== Significant earthquakes (MMI &gt;= 4) ===\")\n        result = await client.get_quakes(mmi=4, limit=3)\n\n        match result:\n            case Ok(response):\n                for quake in response.features:\n                    props = quake.properties\n                    print(f\"M{props.magnitude:.1f} - {props.locality} (MMI: {props.MMI})\")\n            case Err(error):\n                print(f\"Error: {error}\")\n\n        # Client-side magnitude filtering\n        print(\"\\n=== Large earthquakes (magnitude &gt;= 5.0) ===\")\n        result = await client.search_quakes(min_magnitude=5.0, limit=3)\n\n        match result:\n            case Ok(response):\n                for quake in response.features:\n                    props = quake.properties\n                    print(f\"M{props.magnitude:.1f} - {props.locality}\")\n            case Err(error):\n                print(f\"Error: {error}\")\n\nasyncio.run(filter_earthquakes())\n</code></pre>"},{"location":"quickstart/#getting-specific-earthquake-details","title":"Getting Specific Earthquake Details","text":"<p>Retrieve detailed information about a specific earthquake:</p> <pre><code>import asyncio\nfrom quake_cli.client import GeoNetClient\nfrom logerr import Ok, Err\n\nasync def get_earthquake_details():\n    \"\"\"Get details for a specific earthquake.\"\"\"\n    async with GeoNetClient() as client:\n        # First, get a recent earthquake ID\n        recent_result = await client.get_quakes(limit=1)\n\n        match recent_result:\n            case Ok(response):\n                if not response.is_empty:\n                    earthquake_id = response.features[0].properties.publicID\n                    print(f\"Getting details for earthquake: {earthquake_id}\")\n\n                    # Get detailed information\n                    detail_result = await client.get_quake(earthquake_id)\n\n                    match detail_result:\n                        case Ok(quake):\n                            props = quake.properties\n                            print(f\"Detailed info:\")\n                            print(f\"  Time: {props.time}\")\n                            print(f\"  Magnitude: {props.magnitude}\")\n                            print(f\"  Location: {props.locality}\")\n                            print(f\"  Coordinates: {quake.geometry.latitude:.4f}, {quake.geometry.longitude:.4f}\")\n                        case Err(error):\n                            print(f\"Error getting details: {error}\")\n                else:\n                    print(\"No recent earthquakes found\")\n            case Err(error):\n                print(f\"Error: {error}\")\n\nasyncio.run(get_earthquake_details())\n</code></pre>"},{"location":"quickstart/#error-handling-patterns","title":"Error Handling Patterns","text":"<p>The library uses Result types for robust error handling:</p> <pre><code>import asyncio\nfrom quake_cli.client import GeoNetClient, GeoNetError\nfrom logerr import Ok, Err\n\nasync def error_handling_examples():\n    \"\"\"Demonstrate different error handling patterns.\"\"\"\n\n    # Pattern 1: Using match statements (recommended)\n    async with GeoNetClient() as client:\n        result = await client.get_quake(\"invalid-id\")\n\n        match result:\n            case Ok(quake):\n                print(f\"Found earthquake: {quake.properties.locality}\")\n            case Err(error):\n                print(f\"Expected error for invalid ID: {error}\")\n\n    # Pattern 2: Using Result methods\n    async with GeoNetClient() as client:\n        result = await client.get_quakes(limit=1)\n\n        if result.is_ok():\n            response = result.unwrap()\n            print(f\"Success: {response.count} earthquakes\")\n        else:\n            error = result.unwrap_err()\n            print(f\"Error: {error}\")\n\n    # Pattern 3: Chaining operations functionally\n    async with GeoNetClient() as client:\n        result = await client.get_quakes(limit=10)\n\n        # Chain operations with .then()\n        large_quakes = result.then(lambda response:\n            Ok(response.filter_by_magnitude(min_mag=4.0))\n        )\n\n        match large_quakes:\n            case Ok(filtered):\n                print(f\"Found {len(filtered)} large earthquakes\")\n            case Err(error):\n                print(f\"Error: {error}\")\n\nasyncio.run(error_handling_examples())\n</code></pre>"},{"location":"quickstart/#configuration-options","title":"Configuration Options","text":"<p>Customize the client for your needs:</p> <pre><code>import asyncio\nfrom quake_cli.client import GeoNetClient\n\nasync def custom_configuration():\n    \"\"\"Example of custom client configuration.\"\"\"\n\n    # Custom timeout and retry settings\n    custom_client = GeoNetClient(\n        timeout=60.0,           # 60 second timeout\n        retries=5,              # 5 retry attempts\n        retry_min_wait=2.0,     # Minimum 2s between retries\n        retry_max_wait=30.0     # Maximum 30s between retries\n    )\n\n    async with custom_client as client:\n        # Use the custom-configured client\n        result = await client.health_check()\n\n        match result:\n            case Ok(healthy):\n                print(\"API is healthy!\" if healthy else \"API has issues\")\n            case Err(error):\n                print(f\"Health check failed: {error}\")\n\nasyncio.run(custom_configuration())\n</code></pre>"},{"location":"quickstart/#next-steps","title":"Next Steps","text":"<p>Now that you've got the basics:</p> <ol> <li>Explore Examples - See more comprehensive, tested examples</li> <li>API Reference - Detailed documentation of all classes and methods</li> <li>Data Models - Understanding the earthquake data structures</li> <li>HTTP Client - Complete client documentation with all methods</li> </ol>"},{"location":"quickstart/#getting-help","title":"Getting Help","text":"<ul> <li>Issues: GitHub Issues</li> <li>Discussions: GitHub Discussions</li> <li>Documentation: You're reading it! All examples are tested automatically.</li> </ul> <p>Ready to build amazing earthquake monitoring applications! \ud83c\udf0d\u2728</p>"},{"location":"api/","title":"API Reference","text":"<p>This section provides comprehensive documentation for all public APIs in quake-cli, including detailed examples that are automatically tested as part of our test suite.</p>"},{"location":"api/#core-components","title":"Core Components","text":"<ul> <li>Models - Pydantic data models for earthquake data</li> <li>Client - Async HTTP client for GeoNet API</li> <li>Result Types - Functional error handling utilities</li> </ul>"},{"location":"api/#features","title":"Features","text":"<ul> <li>Comprehensive Examples: All code examples in the documentation are automatically tested</li> <li>Type Safety: Full mypy compatibility with modern Python typing</li> <li>Async Support: Complete async/await support throughout the API</li> <li>Functional Error Handling: Uses Result types for composable error handling</li> </ul>"},{"location":"api/#quick-example","title":"Quick Example","text":"<p>Here's a quick example of using the async client:</p> <pre><code>import asyncio\nfrom quake_cli.client import GeoNetClient\nfrom logerr import Ok, Err\n\nasync def get_recent_quakes():\n    async with GeoNetClient() as client:\n        result = await client.get_quakes(limit=5)\n        match result:\n            case Ok(response):\n                print(f\"Found {response.count} earthquakes\")\n                for quake in response.features:\n                    props = quake.properties\n                    print(f\"  {props.publicID}: M{props.magnitude} at {props.locality}\")\n            case Err(error):\n                print(f\"Error: {error}\")\n\n# Run the example\nasyncio.run(get_recent_quakes())\n</code></pre> <p>All examples in this documentation are live code that gets tested automatically to ensure they remain current and functional.</p>"},{"location":"api/cli/","title":"CLI Utilities","text":"<p>The CLI module provides utilities for formatting and displaying earthquake data in terminal applications.</p>"},{"location":"api/cli/#utility-functions","title":"Utility Functions","text":""},{"location":"api/cli/#quake_cli.cli.format_datetime","title":"format_datetime","text":"<pre><code>format_datetime(dt)\n</code></pre> <p>Format datetime for display.</p> <p>Parameters:</p> Name Type Description Default <code>dt</code> <code>datetime</code> <p>The datetime object to format</p> required <p>Returns:</p> Type Description <code>str</code> <p>Formatted datetime string in YYYY-MM-DD HH:MM:SS format</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; dt = datetime(2023, 12, 25, 14, 30, 45)\n&gt;&gt;&gt; format_datetime(dt)\n'2023-12-25 14:30:45'\n</code></pre> <pre><code>&gt;&gt;&gt; dt2 = datetime(2024, 1, 1, 0, 0, 0)\n&gt;&gt;&gt; format_datetime(dt2)\n'2024-01-01 00:00:00'\n</code></pre> Source code in <code>quake_cli/cli.py</code> <pre><code>def format_datetime(dt: datetime) -&gt; str:\n    \"\"\"Format datetime for display.\n\n    Args:\n        dt: The datetime object to format\n\n    Returns:\n        Formatted datetime string in YYYY-MM-DD HH:MM:SS format\n\n    Examples:\n        &gt;&gt;&gt; from datetime import datetime\n        &gt;&gt;&gt; dt = datetime(2023, 12, 25, 14, 30, 45)\n        &gt;&gt;&gt; format_datetime(dt)\n        '2023-12-25 14:30:45'\n\n        &gt;&gt;&gt; dt2 = datetime(2024, 1, 1, 0, 0, 0)\n        &gt;&gt;&gt; format_datetime(dt2)\n        '2024-01-01 00:00:00'\n    \"\"\"\n    return dt.strftime(\"%Y-%m-%d %H:%M:%S\")\n</code></pre>"},{"location":"api/cli/#quake_cli.cli.create_quakes_table","title":"create_quakes_table","text":"<pre><code>create_quakes_table(features, title='Earthquakes')\n</code></pre> <p>Create a rich table for earthquake data.</p> Source code in <code>quake_cli/cli.py</code> <pre><code>def create_quakes_table(\n    features: list[QuakeFeature], title: str = \"Earthquakes\"\n) -&gt; Table:\n    \"\"\"Create a rich table for earthquake data.\"\"\"\n    table = Table(title=title, show_header=True, header_style=\"bold magenta\")\n\n    table.add_column(\"ID\", style=\"cyan\", no_wrap=True)\n    table.add_column(\"Time\", style=\"green\")\n    table.add_column(\"Magnitude\", justify=\"right\", style=\"yellow\")\n    table.add_column(\"Depth (km)\", justify=\"right\", style=\"blue\")\n    table.add_column(\"MMI\", justify=\"right\", style=\"red\")\n    table.add_column(\"Quality\", style=\"dim\")\n    table.add_column(\"Location\", style=\"white\")\n\n    for feature in features:\n        props = feature.properties\n        table.add_row(\n            props.publicID,\n            format_datetime(props.time),\n            f\"{props.magnitude:.1f}\",\n            f\"{props.depth:.1f}\",\n            str(props.MMI) if props.MMI is not None else \"-\",\n            props.quality,\n            props.locality,\n        )\n\n    return table\n</code></pre>"},{"location":"api/cli/#quake_cli.cli.output_data","title":"output_data","text":"<pre><code>output_data(data, format_type, output_file=None)\n</code></pre> <p>Output data in the specified format.</p> Source code in <code>quake_cli/cli.py</code> <pre><code>def output_data(data: Any, format_type: str, output_file: Path | None = None) -&gt; None:\n    \"\"\"Output data in the specified format.\"\"\"\n    match format_type.lower():\n        case \"json\":\n            # Handle JSON output\n            json_output: Any\n            if hasattr(data, \"model_dump\"):\n                json_output = data.model_dump()\n            elif isinstance(data, list):\n                json_output = [\n                    item.model_dump() if hasattr(item, \"model_dump\") else item\n                    for item in data\n                ]\n            else:\n                json_output = data\n\n            json_str = json.dumps(json_output, indent=2, default=str)\n\n            if output_file:\n                output_file.write_text(json_str)\n                print(f\"JSON data written to {output_file!s}\")\n            else:\n                console.print(json_str)\n\n        case \"csv\":\n            # Handle CSV output\n            if hasattr(data, \"features\"):\n                features = data.features\n            elif hasattr(data, \"properties\"):\n                features = [data]\n            elif isinstance(data, list) and data:\n                features = data\n            else:\n                console.print(\n                    \"[red]CSV format only supported for earthquake data[/red]\"\n                )\n                return\n\n            if output_file:\n                with open(output_file, \"w\", newline=\"\") as csvfile:\n                    writer = csv.writer(csvfile)\n                    writer.writerow(\n                        [\n                            \"ID\",\n                            \"Time\",\n                            \"Magnitude\",\n                            \"Depth\",\n                            \"MMI\",\n                            \"Quality\",\n                            \"Location\",\n                            \"Longitude\",\n                            \"Latitude\",\n                        ]\n                    )\n                    for feature in features:\n                        props = feature.properties\n                        geom = feature.geometry\n                        writer.writerow(\n                            [\n                                props.publicID,\n                                props.time.isoformat(),\n                                props.magnitude,\n                                props.depth,\n                                props.MMI,\n                                props.quality,\n                                props.locality,\n                                geom.longitude,\n                                geom.latitude,\n                            ]\n                        )\n                print(f\"CSV data written to {output_file!s}\")\n            else:\n                # Output CSV to console\n                import io\n\n                output = io.StringIO()\n                writer = csv.writer(output)\n                writer.writerow(\n                    [\n                        \"ID\",\n                        \"Time\",\n                        \"Magnitude\",\n                        \"Depth\",\n                        \"MMI\",\n                        \"Quality\",\n                        \"Location\",\n                        \"Longitude\",\n                        \"Latitude\",\n                    ]\n                )\n                for feature in features:\n                    props = feature.properties\n                    geom = feature.geometry\n                    writer.writerow(\n                        [\n                            props.publicID,\n                            props.time.isoformat(),\n                            props.magnitude,\n                            props.depth,\n                            props.MMI,\n                            props.quality,\n                            props.locality,\n                            geom.longitude,\n                            geom.latitude,\n                        ]\n                    )\n                console.print(output.getvalue())\n\n        case \"table\":\n            # Handle table output using match statements\n            match data:\n                case data if isinstance(data, QuakeResponse):\n                    table = create_quakes_table(data.features)\n                    console.print(table)\n                case data if isinstance(data, QuakeFeature):\n                    table = create_quakes_table([data], \"Earthquake Details\")\n                    console.print(table)\n                case data if isinstance(data, (list, tuple)) and data:\n                    # Ensure data is a list of QuakeFeature objects\n                    if all(isinstance(item, QuakeFeature) for item in data):\n                        table = create_quakes_table(list(data))\n                        console.print(table)\n                    else:\n                        console.print(data)\n                case _:\n                    # For other data types, show as JSON-like format\n                    console.print(data)\n\n        case _:\n            console.print(f\"[red]Unknown format: {format_type}[/red]\")\n</code></pre>"},{"location":"api/cli/#error-handling","title":"Error Handling","text":""},{"location":"api/cli/#quake_cli.cli.handle_result","title":"handle_result","text":"<pre><code>handle_result(result)\n</code></pre> <p>Handle Result types and convert errors to CLI exits.</p> Source code in <code>quake_cli/cli.py</code> <pre><code>def handle_result(result: Result) -&gt; Any:\n    \"\"\"Handle Result types and convert errors to CLI exits.\"\"\"\n    match result:\n        case Ok(value):\n            return value\n        case Err(error_msg):\n            if _verbose_logging:\n                # In verbose mode, the error is already logged by logerr\n                console.print(f\"[red]Error:[/red] {error_msg}\")\n            else:\n                # In non-verbose mode, show a clean error message\n                console.print(f\"[red]Error:[/red] {error_msg}\")\n            raise typer.Exit(1)\n</code></pre>"},{"location":"api/cli/#quake_cli.cli.handle_errors","title":"handle_errors","text":"<pre><code>handle_errors(func)\n</code></pre> <p>Decorator to handle common CLI errors.</p> Source code in <code>quake_cli/cli.py</code> <pre><code>def handle_errors(func: Callable[..., Any]) -&gt; Callable[..., Any]:\n    \"\"\"Decorator to handle common CLI errors.\"\"\"\n\n    @wraps(func)\n    def wrapper(*args: Any, **kwargs: Any) -&gt; Any:\n        try:\n            return func(*args, **kwargs)\n        except typer.Exit:\n            # Re-raise typer.Exit to allow proper CLI exit\n            raise\n        except GeoNetError as e:\n            console.print(f\"[red]Error:[/red] {e}\")\n            raise typer.Exit(1) from e\n        except KeyboardInterrupt:\n            console.print(\"\\n[yellow]Interrupted by user[/yellow]\")\n            raise typer.Exit(130) from None\n        except Exception as e:\n            console.print(f\"[red]Unexpected error:[/red] {e}\")\n            raise typer.Exit(1) from e\n\n    return wrapper\n</code></pre>"},{"location":"api/cli/#configuration","title":"Configuration","text":""},{"location":"api/cli/#quake_cli.cli.configure_logging","title":"configure_logging","text":"<pre><code>configure_logging(verbose)\n</code></pre> <p>Configure logging levels based on verbose flag.</p> Source code in <code>quake_cli/cli.py</code> <pre><code>def configure_logging(verbose: bool) -&gt; None:\n    \"\"\"Configure logging levels based on verbose flag.\"\"\"\n    global _verbose_logging\n    _verbose_logging = verbose\n\n    if verbose:\n        # Enable detailed logging with timestamps and levels\n        logger.remove()  # Remove default handler\n        import sys\n\n        logger.add(\n            sys.stderr,\n            format=\"&lt;green&gt;{time:YYYY-MM-DD HH:mm:ss}&lt;/green&gt; | &lt;level&gt;{level: &lt;8}&lt;/level&gt; | &lt;cyan&gt;{name}&lt;/cyan&gt;:&lt;cyan&gt;{function}&lt;/cyan&gt;:&lt;cyan&gt;{line}&lt;/cyan&gt; - &lt;level&gt;{message}&lt;/level&gt;\",\n            level=\"DEBUG\",\n        )\n        console.print(\"[dim]Verbose logging enabled[/dim]\")\n    else:\n        # Remove all handlers to suppress logerr automatic logging\n        logger.remove()\n        # Add a minimal handler that only shows critical errors to stderr\n        import sys\n\n        logger.add(\n            sys.stderr,\n            format=\"&lt;red&gt;{message}&lt;/red&gt;\",\n            level=\"CRITICAL\",\n            filter=lambda record: record[\"level\"].name == \"CRITICAL\",\n        )\n</code></pre>"},{"location":"api/cli/#command-implementations","title":"Command Implementations","text":"<p>The CLI commands (list, get, history, stats, health) are implemented as Typer commands. See the CLI Usage Guide for examples of using the command-line interface.</p>"},{"location":"api/cli/#examples","title":"Examples","text":"<p>All utility functions include comprehensive docstring examples that are automatically tested:</p> <pre><code>from datetime import datetime\nfrom quake_cli.cli import format_datetime\n\n# Format a datetime for display\ndt = datetime(2023, 12, 25, 14, 30, 45)\nformatted = format_datetime(dt)\nprint(formatted)  # Output: \"2023-12-25 14:30:45\"\n</code></pre> <p>The CLI utilities support rich console output with tables, progress bars, and colored text for an excellent user experience.</p>"},{"location":"api/client/","title":"HTTP Client","text":"<p>The GeoNet API client provides async HTTP operations with comprehensive error handling, retry logic, and Result-based return types.</p>"},{"location":"api/client/#main-client","title":"Main Client","text":""},{"location":"api/client/#quake_cli.client.GeoNetClient","title":"GeoNetClient","text":"<pre><code>GeoNetClient(\n    base_url=None,\n    timeout=None,\n    retries=None,\n    retry_min_wait=None,\n    retry_max_wait=None,\n)\n</code></pre> <p>Async client for GeoNet API.</p> <p>Initialize GeoNet API client.</p> <p>Parameters:</p> Name Type Description Default <code>base_url</code> <code>str | None</code> <p>Base URL for GeoNet API (default from env or https://api.geonet.org.nz/)</p> <code>None</code> <code>timeout</code> <code>float | None</code> <p>Request timeout in seconds (default from env or 30)</p> <code>None</code> <code>retries</code> <code>int | None</code> <p>Number of retry attempts (default from env or 3)</p> <code>None</code> <code>retry_min_wait</code> <code>float | None</code> <p>Minimum wait time between retries (default from env or 4)</p> <code>None</code> <code>retry_max_wait</code> <code>float | None</code> <p>Maximum wait time between retries (default from env or 10)</p> <code>None</code> Source code in <code>quake_cli/client.py</code> <pre><code>def __init__(\n    self,\n    base_url: str | None = None,\n    timeout: float | None = None,\n    retries: int | None = None,\n    retry_min_wait: float | None = None,\n    retry_max_wait: float | None = None,\n) -&gt; None:\n    \"\"\"\n    Initialize GeoNet API client.\n\n    Args:\n        base_url: Base URL for GeoNet API (default from env or https://api.geonet.org.nz/)\n        timeout: Request timeout in seconds (default from env or 30)\n        retries: Number of retry attempts (default from env or 3)\n        retry_min_wait: Minimum wait time between retries (default from env or 4)\n        retry_max_wait: Maximum wait time between retries (default from env or 10)\n    \"\"\"\n    self.base_url = base_url or os.getenv(\n        \"GEONET_API_URL\", \"https://api.geonet.org.nz/\"\n    )\n    self.timeout = timeout or float(os.getenv(\"GEONET_TIMEOUT\", \"30\"))\n    self.retries = retries or int(os.getenv(\"GEONET_RETRIES\", \"3\"))\n    self.retry_min_wait = retry_min_wait or float(\n        os.getenv(\"GEONET_RETRY_MIN_WAIT\", \"4\")\n    )\n    self.retry_max_wait = retry_max_wait or float(\n        os.getenv(\"GEONET_RETRY_MAX_WAIT\", \"10\")\n    )\n\n    self.client: httpx.AsyncClient | None = None\n</code></pre>"},{"location":"api/client/#quake_cli.client.GeoNetClient.get_quakes","title":"get_quakes  <code>async</code>","text":"<pre><code>get_quakes(mmi=None, limit=None)\n</code></pre> <p>Get earthquake data from GeoNet API.</p> <p>Parameters:</p> Name Type Description Default <code>mmi</code> <code>int | None</code> <p>Modified Mercalli Intensity filter (-1 to 8, API range)</p> <code>None</code> <code>limit</code> <code>int | None</code> <p>Maximum number of results (applied client-side)</p> <code>None</code> <p>Returns:</p> Type Description <code>QuakeResult</code> <p>Result containing QuakeResponse or error message</p> Source code in <code>quake_cli/client.py</code> <pre><code>async def get_quakes(\n    self,\n    mmi: int | None = None,\n    limit: int | None = None,\n) -&gt; QuakeResult:\n    \"\"\"\n    Get earthquake data from GeoNet API.\n\n    Args:\n        mmi: Modified Mercalli Intensity filter (-1 to 8, API range)\n        limit: Maximum number of results (applied client-side)\n\n    Returns:\n        Result containing QuakeResponse or error message\n    \"\"\"\n    params: dict[str, Any] = {}\n\n    # MMI parameter is required by the API\n    if mmi is not None:\n        if not -1 &lt;= mmi &lt;= 8:\n            return Err(\"MMI must be between -1 and 8\")\n        params[\"MMI\"] = mmi\n    else:\n        # Default to MMI=-1 to get all earthquakes\n        params[\"MMI\"] = -1\n\n    # Make the API request and chain operations\n    result = await self._make_request(\"quake\", params)\n\n    def parse_and_limit_response(data: dict[str, Any]) -&gt; QuakeResult:\n        try:\n            response = QuakeResponse.model_validate(data)\n            # Apply client-side limit if specified\n            if limit is not None and limit &gt; 0:\n                response.features = response.features[:limit]\n            return Ok(response)\n        except Exception as e:\n            return Err(f\"Failed to parse response: {e!s}\")\n\n    return result.then(parse_and_limit_response)\n</code></pre>"},{"location":"api/client/#quake_cli.client.GeoNetClient.get_quake","title":"get_quake  <code>async</code>","text":"<pre><code>get_quake(public_id)\n</code></pre> <p>Get a specific earthquake by its publicID.</p> <p>Parameters:</p> Name Type Description Default <code>public_id</code> <code>str</code> <p>Unique earthquake identifier</p> required <p>Returns:</p> Type Description <code>FeatureResult</code> <p>Result containing QuakeFeature or error message</p> Source code in <code>quake_cli/client.py</code> <pre><code>async def get_quake(self, public_id: str) -&gt; FeatureResult:\n    \"\"\"\n    Get a specific earthquake by its publicID.\n\n    Args:\n        public_id: Unique earthquake identifier\n\n    Returns:\n        Result containing QuakeFeature or error message\n    \"\"\"\n    # Make the API request and chain operations\n    # Trust type system: public_id is typed as str and validated at boundaries\n    result = await self._make_request(f\"quake/{public_id.strip()}\")\n\n    def parse_and_extract_feature(data: dict[str, Any]) -&gt; FeatureResult:\n        try:\n            response = QuakeResponse.model_validate(data)\n            match response.is_empty:\n                case True:\n                    return Err(f\"Earthquake {public_id} not found\")\n                case False:\n                    return Ok(response.features[0])\n        except Exception as e:\n            return Err(f\"Failed to parse response: {e!s}\")\n\n    return result.then(parse_and_extract_feature)\n</code></pre>"},{"location":"api/client/#quake_cli.client.GeoNetClient.get_quake_history","title":"get_quake_history  <code>async</code>","text":"<pre><code>get_quake_history(public_id)\n</code></pre> <p>Get location history for a specific earthquake.</p> <p>Parameters:</p> Name Type Description Default <code>public_id</code> <code>str</code> <p>Unique earthquake identifier</p> required <p>Returns:</p> Type Description <code>HistoryResult</code> <p>Result containing location history records or error message</p> Source code in <code>quake_cli/client.py</code> <pre><code>async def get_quake_history(self, public_id: str) -&gt; HistoryResult:\n    \"\"\"\n    Get location history for a specific earthquake.\n\n    Args:\n        public_id: Unique earthquake identifier\n\n    Returns:\n        Result containing location history records or error message\n    \"\"\"\n    # Make the API request and process data\n    # Trust type system: public_id is typed as str and validated at boundaries\n    result = await self._make_request(f\"quake/history/{public_id.strip()}\")\n\n    def normalize_history_data(data: dict[str, Any] | list[Any]) -&gt; HistoryResult:\n        history = data if isinstance(data, list) else [data]\n        return Ok(history)\n\n    return result.then(normalize_history_data)\n</code></pre>"},{"location":"api/client/#quake_cli.client.GeoNetClient.get_quake_stats","title":"get_quake_stats  <code>async</code>","text":"<pre><code>get_quake_stats()\n</code></pre> <p>Get earthquake statistics.</p> <p>Returns:</p> Type Description <code>StatsResult</code> <p>Result containing earthquake statistics or error message</p> Note <p>The exact structure of stats response depends on the API implementation. This returns raw data for now until we can verify the actual structure.</p> Source code in <code>quake_cli/client.py</code> <pre><code>async def get_quake_stats(self) -&gt; StatsResult:\n    \"\"\"\n    Get earthquake statistics.\n\n    Returns:\n        Result containing earthquake statistics or error message\n\n    Note:\n        The exact structure of stats response depends on the API implementation.\n        This returns raw data for now until we can verify the actual structure.\n    \"\"\"\n    return await self._make_request(\"quake/stats\")\n</code></pre>"},{"location":"api/client/#quake_cli.client.GeoNetClient.search_quakes","title":"search_quakes  <code>async</code>","text":"<pre><code>search_quakes(\n    min_magnitude=None,\n    max_magnitude=None,\n    min_mmi=None,\n    max_mmi=None,\n    limit=None,\n)\n</code></pre> <p>Search earthquakes with filtering options.</p> <p>This method gets all quakes and applies client-side filtering. For server-side MMI filtering, use get_quakes() with mmi parameter.</p> <p>Parameters:</p> Name Type Description Default <code>min_magnitude</code> <code>float | None</code> <p>Minimum magnitude threshold</p> <code>None</code> <code>max_magnitude</code> <code>float | None</code> <p>Maximum magnitude threshold</p> <code>None</code> <code>min_mmi</code> <code>int | None</code> <p>Minimum Modified Mercalli Intensity</p> <code>None</code> <code>max_mmi</code> <code>int | None</code> <p>Maximum Modified Mercalli Intensity</p> <code>None</code> <code>limit</code> <code>int | None</code> <p>Maximum number of results</p> <code>None</code> <p>Returns:</p> Type Description <code>QuakeResult</code> <p>Result containing filtered QuakeResponse or error message</p> Source code in <code>quake_cli/client.py</code> <pre><code>async def search_quakes(\n    self,\n    min_magnitude: float | None = None,\n    max_magnitude: float | None = None,\n    min_mmi: int | None = None,\n    max_mmi: int | None = None,\n    limit: int | None = None,\n) -&gt; QuakeResult:\n    \"\"\"\n    Search earthquakes with filtering options.\n\n    This method gets all quakes and applies client-side filtering.\n    For server-side MMI filtering, use get_quakes() with mmi parameter.\n\n    Args:\n        min_magnitude: Minimum magnitude threshold\n        max_magnitude: Maximum magnitude threshold\n        min_mmi: Minimum Modified Mercalli Intensity\n        max_mmi: Maximum Modified Mercalli Intensity\n        limit: Maximum number of results\n\n    Returns:\n        Result containing filtered QuakeResponse or error message\n    \"\"\"\n    # Get all quakes first and apply filters\n    result = await self.get_quakes()\n\n    def apply_filters(response: QuakeResponse) -&gt; QuakeResult:\n        # Apply magnitude filters\n        if min_magnitude is not None or max_magnitude is not None:\n            response.features = response.filter_by_magnitude(\n                min_magnitude, max_magnitude\n            )\n\n        # Apply MMI filters\n        if min_mmi is not None or max_mmi is not None:\n            response.features = response.filter_by_mmi(min_mmi, max_mmi)\n\n        # Apply limit\n        if limit is not None and limit &gt; 0:\n            response.features = response.features[:limit]\n\n        return Ok(response)\n\n    return result.then(apply_filters)\n</code></pre>"},{"location":"api/client/#quake_cli.client.GeoNetClient.health_check","title":"health_check  <code>async</code>","text":"<pre><code>health_check()\n</code></pre> <p>Check if the GeoNet API is accessible.</p> <p>Returns:</p> Type Description <code>Result[bool, str]</code> <p>Result containing True if API is accessible, error message otherwise</p> Source code in <code>quake_cli/client.py</code> <pre><code>async def health_check(self) -&gt; Result[bool, str]:\n    \"\"\"\n    Check if the GeoNet API is accessible.\n\n    Returns:\n        Result containing True if API is accessible, error message otherwise\n    \"\"\"\n    # Use the quake endpoint with a minimal request for health check\n    result = await self._make_request(\"quake\", {\"MMI\": -1})\n\n    # Use functional approach with .then() for better type safety\n    return result.then(lambda _: Ok(True)).map_err(\n        lambda error: f\"Health check failed: {error}\"\n    )\n</code></pre>"},{"location":"api/client/#exception-classes","title":"Exception Classes","text":""},{"location":"api/client/#quake_cli.client.GeoNetError","title":"GeoNetError","text":"<pre><code>GeoNetError(message, status_code=None)\n</code></pre> <p>               Bases: <code>Exception</code></p> <p>Base exception for GeoNet API errors.</p> Source code in <code>quake_cli/client.py</code> <pre><code>def __init__(self, message: str, status_code: int | None = None) -&gt; None:\n    super().__init__(message)\n    self.status_code = status_code\n</code></pre>"},{"location":"api/client/#quake_cli.client.GeoNetConnectionError","title":"GeoNetConnectionError","text":"<pre><code>GeoNetConnectionError(message, status_code=None)\n</code></pre> <p>               Bases: <code>GeoNetError</code></p> <p>Raised when unable to connect to GeoNet API.</p> Source code in <code>quake_cli/client.py</code> <pre><code>def __init__(self, message: str, status_code: int | None = None) -&gt; None:\n    super().__init__(message)\n    self.status_code = status_code\n</code></pre>"},{"location":"api/client/#quake_cli.client.GeoNetTimeoutError","title":"GeoNetTimeoutError","text":"<pre><code>GeoNetTimeoutError(message, status_code=None)\n</code></pre> <p>               Bases: <code>GeoNetError</code></p> <p>Raised when GeoNet API request times out.</p> Source code in <code>quake_cli/client.py</code> <pre><code>def __init__(self, message: str, status_code: int | None = None) -&gt; None:\n    super().__init__(message)\n    self.status_code = status_code\n</code></pre>"},{"location":"api/client/#type-aliases","title":"Type Aliases","text":"<p>The client module exports several Result type aliases for type safety:</p>"},{"location":"api/client/#quake_cli.client.QuakeResult","title":"QuakeResult","text":"<pre><code>QuakeResult = Result[QuakeResponse, str]\n</code></pre>"},{"location":"api/client/#quake_cli.client.FeatureResult","title":"FeatureResult","text":"<pre><code>FeatureResult = Result[QuakeFeature, str]\n</code></pre>"},{"location":"api/client/#quake_cli.client.DataResult","title":"DataResult","text":"<pre><code>DataResult = Result[dict[str, Any], str]\n</code></pre>"},{"location":"api/client/#quake_cli.client.StatsResult","title":"StatsResult","text":"<pre><code>StatsResult = Result[dict[str, Any], str]\n</code></pre>"},{"location":"api/client/#quake_cli.client.HistoryResult","title":"HistoryResult","text":"<pre><code>HistoryResult = Result[list[Any], str]\n</code></pre>"},{"location":"api/client/#usage-examples","title":"Usage Examples","text":""},{"location":"api/client/#basic-usage","title":"Basic Usage","text":"<pre><code>import asyncio\nfrom quake_cli.client import GeoNetClient\n\nasync def example():\n    async with GeoNetClient() as client:\n        # Get recent earthquakes\n        result = await client.get_quakes(limit=10)\n\n        match result:\n            case Ok(response):\n                print(f\"Found {response.count} earthquakes\")\n            case Err(error):\n                print(f\"Error: {error}\")\n\nasyncio.run(example())\n</code></pre>"},{"location":"api/client/#custom-configuration","title":"Custom Configuration","text":"<pre><code># Configure client with custom settings\nclient = GeoNetClient(\n    base_url=\"https://api.geonet.org.nz/\",\n    timeout=60.0,\n    retries=5,\n    retry_min_wait=2.0,\n    retry_max_wait=30.0\n)\n</code></pre>"},{"location":"api/client/#error-handling","title":"Error Handling","text":"<p>The client uses functional error handling with Result types:</p> <pre><code>async def handle_errors():\n    async with GeoNetClient() as client:\n        result = await client.get_quake(\"invalid-id\")\n\n        # Pattern matching for clean error handling\n        match result:\n            case Ok(quake):\n                print(f\"Quake: {quake.properties.locality}\")\n            case Err(error):\n                print(f\"Failed to get quake: {error}\")\n\n        # Or use the Result API\n        if result.is_ok():\n            quake = result.unwrap()\n            print(f\"Success: {quake.properties.magnitude}\")\n        else:\n            print(f\"Error: {result.unwrap_err()}\")\n</code></pre>"},{"location":"api/models/","title":"Data Models","text":"<p>The quake-cli package provides comprehensive Pydantic models for handling earthquake data from the GeoNet API. All models include validation, type hints, and extensive examples.</p>"},{"location":"api/models/#core-models","title":"Core Models","text":""},{"location":"api/models/#quake_cli.models.QuakeGeometry","title":"QuakeGeometry","text":"<p>               Bases: <code>BaseModel</code></p> <p>Geometry information for a quake (GeoJSON Point).</p>"},{"location":"api/models/#quake_cli.models.QuakeGeometry.longitude","title":"longitude  <code>property</code>","text":"<pre><code>longitude\n</code></pre> <p>Longitude coordinate.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; geom = QuakeGeometry(type=\"Point\", coordinates=[174.123, -41.456])\n&gt;&gt;&gt; geom.longitude\n174.123\n</code></pre>"},{"location":"api/models/#quake_cli.models.QuakeGeometry.latitude","title":"latitude  <code>property</code>","text":"<pre><code>latitude\n</code></pre> <p>Latitude coordinate.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; geom = QuakeGeometry(type=\"Point\", coordinates=[174.123, -41.456])\n&gt;&gt;&gt; geom.latitude\n-41.456\n</code></pre>"},{"location":"api/models/#quake_cli.models.QuakeGeometry.depth","title":"depth  <code>property</code>","text":"<pre><code>depth\n</code></pre> <p>Depth coordinate if available (should match properties.depth).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; geom = QuakeGeometry(type=\"Point\", coordinates=[174.123, -41.456, 5.2])\n&gt;&gt;&gt; geom.depth\n5.2\n</code></pre> <pre><code>&gt;&gt;&gt; geom_2d = QuakeGeometry(type=\"Point\", coordinates=[174.123, -41.456])\n&gt;&gt;&gt; geom_2d.depth is None\nTrue\n</code></pre>"},{"location":"api/models/#quake_cli.models.QuakeProperties","title":"QuakeProperties","text":"<p>               Bases: <code>BaseModel</code></p> <p>Properties of a quake event.</p>"},{"location":"api/models/#quake_cli.models.QuakeProperties.validate_locality","title":"validate_locality  <code>classmethod</code>","text":"<pre><code>validate_locality(v)\n</code></pre> <p>Validate locality is not empty.</p> Source code in <code>quake_cli/models.py</code> <pre><code>@field_validator(\"locality\")\n@classmethod\ndef validate_locality(cls, v: str) -&gt; str:\n    \"\"\"Validate locality is not empty.\"\"\"\n    if not v.strip():\n        raise ValueError(\"locality cannot be empty\")\n    return v.strip()\n</code></pre>"},{"location":"api/models/#quake_cli.models.QuakeProperties.validate_public_id","title":"validate_public_id  <code>classmethod</code>","text":"<pre><code>validate_public_id(v)\n</code></pre> <p>Validate publicID format.</p> Source code in <code>quake_cli/models.py</code> <pre><code>@field_validator(\"publicID\")\n@classmethod\ndef validate_public_id(cls, v: str) -&gt; str:\n    \"\"\"Validate publicID format.\"\"\"\n    if not v.strip():\n        raise ValueError(\"publicID cannot be empty\")\n    return v.strip()\n</code></pre>"},{"location":"api/models/#quake_cli.models.QuakeFeature","title":"QuakeFeature","text":"<p>               Bases: <code>BaseModel</code></p> <p>A single earthquake feature (GeoJSON Feature).</p>"},{"location":"api/models/#quake_cli.models.QuakeFeature.validate_geometry_depth_matches","title":"validate_geometry_depth_matches  <code>classmethod</code>","text":"<pre><code>validate_geometry_depth_matches(v, info)\n</code></pre> <p>Ensure geometry depth matches properties depth if available.</p> Source code in <code>quake_cli/models.py</code> <pre><code>@field_validator(\"geometry\")\n@classmethod\ndef validate_geometry_depth_matches(\n    cls, v: QuakeGeometry, info: ValidationInfo\n) -&gt; QuakeGeometry:\n    \"\"\"Ensure geometry depth matches properties depth if available.\"\"\"\n    if hasattr(info, \"data\") and \"properties\" in info.data and v.depth is not None:\n        properties_depth = info.data[\"properties\"].depth\n        if (\n            abs(v.depth - properties_depth) &gt; 0.001\n        ):  # Allow for floating point precision\n            raise ValueError(\n                f\"Geometry depth ({v.depth}) must match properties depth ({properties_depth})\"\n            )\n    return v\n</code></pre>"},{"location":"api/models/#quake_cli.models.QuakeResponse","title":"QuakeResponse","text":"<p>               Bases: <code>BaseModel</code></p> <p>Response from GeoNet quake API endpoints.</p>"},{"location":"api/models/#quake_cli.models.QuakeResponse.count","title":"count  <code>property</code>","text":"<pre><code>count\n</code></pre> <p>Number of quakes in the response.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; response = QuakeResponse(type=\"FeatureCollection\", features=[])\n&gt;&gt;&gt; response.count\n0\n</code></pre> <pre><code>&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; props = QuakeProperties(\n...     publicID=\"2023geonet001\",\n...     time=datetime(2023, 1, 1, 12, 0, 0),\n...     depth=5.0,\n...     magnitude=4.5,\n...     locality=\"Wellington\",\n...     quality=\"best\"\n... )\n&gt;&gt;&gt; geom = QuakeGeometry(type=\"Point\", coordinates=[174.123, -41.456])\n&gt;&gt;&gt; feature = QuakeFeature(type=\"Feature\", properties=props, geometry=geom)\n&gt;&gt;&gt; response_with_data = QuakeResponse(type=\"FeatureCollection\", features=[feature])\n&gt;&gt;&gt; response_with_data.count\n1\n</code></pre>"},{"location":"api/models/#quake_cli.models.QuakeResponse.is_empty","title":"is_empty  <code>property</code>","text":"<pre><code>is_empty\n</code></pre> <p>Whether the response contains no quakes.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; response = QuakeResponse(type=\"FeatureCollection\", features=[])\n&gt;&gt;&gt; response.is_empty\nTrue\n</code></pre> <pre><code>&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; props = QuakeProperties(\n...     publicID=\"2023geonet001\",\n...     time=datetime(2023, 1, 1, 12, 0, 0),\n...     depth=5.0,\n...     magnitude=4.5,\n...     locality=\"Wellington\",\n...     quality=\"best\"\n... )\n&gt;&gt;&gt; geom = QuakeGeometry(type=\"Point\", coordinates=[174.123, -41.456])\n&gt;&gt;&gt; feature = QuakeFeature(type=\"Feature\", properties=props, geometry=geom)\n&gt;&gt;&gt; response_with_data = QuakeResponse(type=\"FeatureCollection\", features=[feature])\n&gt;&gt;&gt; response_with_data.is_empty\nFalse\n</code></pre>"},{"location":"api/models/#quake_cli.models.QuakeResponse.get_by_id","title":"get_by_id","text":"<pre><code>get_by_id(public_id)\n</code></pre> <p>Get a quake by its publicID.</p> <p>Parameters:</p> Name Type Description Default <code>public_id</code> <code>str</code> <p>The unique earthquake identifier to search for</p> required <p>Returns:</p> Type Description <code>QuakeFeature | None</code> <p>The matching QuakeFeature or None if not found</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; props = QuakeProperties(\n...     publicID=\"2023geonet001\",\n...     time=datetime(2023, 1, 1, 12, 0, 0),\n...     depth=5.0,\n...     magnitude=4.5,\n...     locality=\"Wellington\",\n...     quality=\"best\"\n... )\n&gt;&gt;&gt; geom = QuakeGeometry(type=\"Point\", coordinates=[174.123, -41.456])\n&gt;&gt;&gt; feature = QuakeFeature(type=\"Feature\", properties=props, geometry=geom)\n&gt;&gt;&gt; response = QuakeResponse(type=\"FeatureCollection\", features=[feature])\n&gt;&gt;&gt; found = response.get_by_id(\"2023geonet001\")\n&gt;&gt;&gt; found is not None\nTrue\n&gt;&gt;&gt; found.properties.publicID\n'2023geonet001'\n</code></pre> <pre><code>&gt;&gt;&gt; not_found = response.get_by_id(\"nonexistent\")\n&gt;&gt;&gt; not_found is None\nTrue\n</code></pre> Source code in <code>quake_cli/models.py</code> <pre><code>def get_by_id(self, public_id: str) -&gt; QuakeFeature | None:\n    \"\"\"Get a quake by its publicID.\n\n    Args:\n        public_id: The unique earthquake identifier to search for\n\n    Returns:\n        The matching QuakeFeature or None if not found\n\n    Examples:\n        &gt;&gt;&gt; from datetime import datetime\n        &gt;&gt;&gt; props = QuakeProperties(\n        ...     publicID=\"2023geonet001\",\n        ...     time=datetime(2023, 1, 1, 12, 0, 0),\n        ...     depth=5.0,\n        ...     magnitude=4.5,\n        ...     locality=\"Wellington\",\n        ...     quality=\"best\"\n        ... )\n        &gt;&gt;&gt; geom = QuakeGeometry(type=\"Point\", coordinates=[174.123, -41.456])\n        &gt;&gt;&gt; feature = QuakeFeature(type=\"Feature\", properties=props, geometry=geom)\n        &gt;&gt;&gt; response = QuakeResponse(type=\"FeatureCollection\", features=[feature])\n        &gt;&gt;&gt; found = response.get_by_id(\"2023geonet001\")\n        &gt;&gt;&gt; found is not None\n        True\n        &gt;&gt;&gt; found.properties.publicID\n        '2023geonet001'\n\n        &gt;&gt;&gt; not_found = response.get_by_id(\"nonexistent\")\n        &gt;&gt;&gt; not_found is None\n        True\n    \"\"\"\n    for feature in self.features:\n        if feature.properties.publicID == public_id:\n            return feature\n    return None\n</code></pre>"},{"location":"api/models/#quake_cli.models.QuakeResponse.filter_by_magnitude","title":"filter_by_magnitude","text":"<pre><code>filter_by_magnitude(min_mag=None, max_mag=None)\n</code></pre> <p>Filter quakes by magnitude range.</p> <p>Parameters:</p> Name Type Description Default <code>min_mag</code> <code>float | None</code> <p>Minimum magnitude (inclusive), or None for no minimum</p> <code>None</code> <code>max_mag</code> <code>float | None</code> <p>Maximum magnitude (inclusive), or None for no maximum</p> <code>None</code> <p>Returns:</p> Type Description <code>list[QuakeFeature]</code> <p>List of QuakeFeatures within the magnitude range</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; props1 = QuakeProperties(\n...     publicID=\"quake1\", time=datetime(2023, 1, 1),\n...     depth=5.0, magnitude=3.0, locality=\"Place1\", quality=\"best\"\n... )\n&gt;&gt;&gt; props2 = QuakeProperties(\n...     publicID=\"quake2\", time=datetime(2023, 1, 2),\n...     depth=10.0, magnitude=5.0, locality=\"Place2\", quality=\"best\"\n... )\n&gt;&gt;&gt; geom = QuakeGeometry(type=\"Point\", coordinates=[174.0, -41.0])\n&gt;&gt;&gt; features = [\n...     QuakeFeature(type=\"Feature\", properties=props1, geometry=geom),\n...     QuakeFeature(type=\"Feature\", properties=props2, geometry=geom)\n... ]\n&gt;&gt;&gt; response = QuakeResponse(type=\"FeatureCollection\", features=features)\n&gt;&gt;&gt; filtered = response.filter_by_magnitude(min_mag=4.0)\n&gt;&gt;&gt; len(filtered)\n1\n&gt;&gt;&gt; filtered[0].properties.magnitude\n5.0\n</code></pre> Source code in <code>quake_cli/models.py</code> <pre><code>def filter_by_magnitude(\n    self, min_mag: float | None = None, max_mag: float | None = None\n) -&gt; list[QuakeFeature]:\n    \"\"\"Filter quakes by magnitude range.\n\n    Args:\n        min_mag: Minimum magnitude (inclusive), or None for no minimum\n        max_mag: Maximum magnitude (inclusive), or None for no maximum\n\n    Returns:\n        List of QuakeFeatures within the magnitude range\n\n    Examples:\n        &gt;&gt;&gt; from datetime import datetime\n        &gt;&gt;&gt; props1 = QuakeProperties(\n        ...     publicID=\"quake1\", time=datetime(2023, 1, 1),\n        ...     depth=5.0, magnitude=3.0, locality=\"Place1\", quality=\"best\"\n        ... )\n        &gt;&gt;&gt; props2 = QuakeProperties(\n        ...     publicID=\"quake2\", time=datetime(2023, 1, 2),\n        ...     depth=10.0, magnitude=5.0, locality=\"Place2\", quality=\"best\"\n        ... )\n        &gt;&gt;&gt; geom = QuakeGeometry(type=\"Point\", coordinates=[174.0, -41.0])\n        &gt;&gt;&gt; features = [\n        ...     QuakeFeature(type=\"Feature\", properties=props1, geometry=geom),\n        ...     QuakeFeature(type=\"Feature\", properties=props2, geometry=geom)\n        ... ]\n        &gt;&gt;&gt; response = QuakeResponse(type=\"FeatureCollection\", features=features)\n        &gt;&gt;&gt; filtered = response.filter_by_magnitude(min_mag=4.0)\n        &gt;&gt;&gt; len(filtered)\n        1\n        &gt;&gt;&gt; filtered[0].properties.magnitude\n        5.0\n    \"\"\"\n    filtered = self.features\n\n    if min_mag is not None:\n        filtered = [f for f in filtered if f.properties.magnitude &gt;= min_mag]\n\n    if max_mag is not None:\n        filtered = [f for f in filtered if f.properties.magnitude &lt;= max_mag]\n\n    return filtered\n</code></pre>"},{"location":"api/models/#quake_cli.models.QuakeResponse.filter_by_mmi","title":"filter_by_mmi","text":"<pre><code>filter_by_mmi(min_mmi=None, max_mmi=None)\n</code></pre> <p>Filter quakes by Modified Mercalli Intensity range.</p> <p>Parameters:</p> Name Type Description Default <code>min_mmi</code> <code>int | None</code> <p>Minimum MMI (inclusive), or None for no minimum</p> <code>None</code> <code>max_mmi</code> <code>int | None</code> <p>Maximum MMI (inclusive), or None for no maximum</p> <code>None</code> <p>Returns:</p> Type Description <code>list[QuakeFeature]</code> <p>List of QuakeFeatures within the MMI range (excludes features with MMI=None)</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; props1 = QuakeProperties(\n...     publicID=\"quake1\", time=datetime(2023, 1, 1),\n...     depth=5.0, magnitude=3.0, locality=\"Place1\", quality=\"best\", mmi=2\n... )\n&gt;&gt;&gt; props2 = QuakeProperties(\n...     publicID=\"quake2\", time=datetime(2023, 1, 2),\n...     depth=10.0, magnitude=5.0, locality=\"Place2\", quality=\"best\", mmi=5\n... )\n&gt;&gt;&gt; geom = QuakeGeometry(type=\"Point\", coordinates=[174.0, -41.0])\n&gt;&gt;&gt; features = [\n...     QuakeFeature(type=\"Feature\", properties=props1, geometry=geom),\n...     QuakeFeature(type=\"Feature\", properties=props2, geometry=geom)\n... ]\n&gt;&gt;&gt; response = QuakeResponse(type=\"FeatureCollection\", features=features)\n&gt;&gt;&gt; filtered = response.filter_by_mmi(min_mmi=3)\n&gt;&gt;&gt; len(filtered)\n1\n&gt;&gt;&gt; filtered[0].properties.MMI\n5\n</code></pre> Source code in <code>quake_cli/models.py</code> <pre><code>def filter_by_mmi(\n    self, min_mmi: int | None = None, max_mmi: int | None = None\n) -&gt; list[QuakeFeature]:\n    \"\"\"Filter quakes by Modified Mercalli Intensity range.\n\n    Args:\n        min_mmi: Minimum MMI (inclusive), or None for no minimum\n        max_mmi: Maximum MMI (inclusive), or None for no maximum\n\n    Returns:\n        List of QuakeFeatures within the MMI range (excludes features with MMI=None)\n\n    Examples:\n        &gt;&gt;&gt; from datetime import datetime\n        &gt;&gt;&gt; props1 = QuakeProperties(\n        ...     publicID=\"quake1\", time=datetime(2023, 1, 1),\n        ...     depth=5.0, magnitude=3.0, locality=\"Place1\", quality=\"best\", mmi=2\n        ... )\n        &gt;&gt;&gt; props2 = QuakeProperties(\n        ...     publicID=\"quake2\", time=datetime(2023, 1, 2),\n        ...     depth=10.0, magnitude=5.0, locality=\"Place2\", quality=\"best\", mmi=5\n        ... )\n        &gt;&gt;&gt; geom = QuakeGeometry(type=\"Point\", coordinates=[174.0, -41.0])\n        &gt;&gt;&gt; features = [\n        ...     QuakeFeature(type=\"Feature\", properties=props1, geometry=geom),\n        ...     QuakeFeature(type=\"Feature\", properties=props2, geometry=geom)\n        ... ]\n        &gt;&gt;&gt; response = QuakeResponse(type=\"FeatureCollection\", features=features)\n        &gt;&gt;&gt; filtered = response.filter_by_mmi(min_mmi=3)\n        &gt;&gt;&gt; len(filtered)\n        1\n        &gt;&gt;&gt; filtered[0].properties.MMI\n        5\n    \"\"\"\n    filtered = [f for f in self.features if f.properties.MMI is not None]\n\n    if min_mmi is not None:\n        filtered = [\n            f\n            for f in filtered\n            if f.properties.MMI is not None and min_mmi &lt;= f.properties.MMI\n        ]\n\n    if max_mmi is not None:\n        filtered = [\n            f\n            for f in filtered\n            if f.properties.MMI is not None and max_mmi &gt;= f.properties.MMI\n        ]\n\n    return filtered\n</code></pre>"},{"location":"api/models/#quake_cli.models.QuakeStatsResponse","title":"QuakeStatsResponse","text":"<p>               Bases: <code>BaseModel</code></p> <p>Response from the quake stats endpoint.</p>"},{"location":"api/models/#type-aliases","title":"Type Aliases","text":""},{"location":"api/models/#quake_cli.models.QualityType","title":"QualityType","text":"<pre><code>QualityType = Literal[\n    \"best\", \"preliminary\", \"automatic\", \"deleted\"\n]\n</code></pre>"},{"location":"api/models/#examples-in-action","title":"Examples in Action","text":"<p>All the examples shown in the docstrings above are automatically tested as part of our test suite. This ensures that:</p> <ul> <li>\u2705 Examples remain current and functional</li> <li>\u2705 Code changes that break examples are caught immediately</li> <li>\u2705 Documentation stays synchronized with the codebase</li> <li>\u2705 Users can trust that examples will work as shown</li> </ul> <p>To run the docstring tests yourself:</p> <pre><code># Test all doctests\npixi run python -m pytest --doctest-modules quake_cli/\n\n# Test just the models\npixi run python -m doctest quake_cli/models.py -v\n</code></pre>"},{"location":"api/result/","title":"Result Types","text":"<p>The result module provides functional error handling utilities using the <code>logerr</code> library's Result types.</p>"},{"location":"api/result/#error-handling-functions","title":"Error Handling Functions","text":""},{"location":"api/result/#quake_cli.result.handle_api_error","title":"handle_api_error","text":"<pre><code>handle_api_error(error)\n</code></pre> <p>Convert exceptions to Result types with automatic logging.</p> <p>Parameters:</p> Name Type Description Default <code>error</code> <code>Exception</code> <p>The exception to handle</p> required <p>Returns:</p> Type Description <code>Result[T, str]</code> <p>An err Result with error message</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; error = ValueError(\"Invalid input\")\n&gt;&gt;&gt; result = handle_api_error(error)\n&gt;&gt;&gt; result.is_err()\nTrue\n&gt;&gt;&gt; result.unwrap_err()\n'Invalid input'\n</code></pre> Source code in <code>quake_cli/result.py</code> <pre><code>def handle_api_error(error: Exception) -&gt; Result[T, str]:\n    \"\"\"\n    Convert exceptions to Result types with automatic logging.\n\n    Args:\n        error: The exception to handle\n\n    Returns:\n        An err Result with error message\n\n    Examples:\n        &gt;&gt;&gt; error = ValueError(\"Invalid input\")\n        &gt;&gt;&gt; result = handle_api_error(error)\n        &gt;&gt;&gt; result.is_err()\n        True\n        &gt;&gt;&gt; result.unwrap_err()\n        'Invalid input'\n    \"\"\"\n    error_msg = str(error)\n    logger.error(f\"API error occurred: {error_msg}\")\n    return Err(error_msg)\n</code></pre>"},{"location":"api/result/#type-aliases","title":"Type Aliases","text":"<p>The module exports several type aliases for common Result patterns:</p>"},{"location":"api/result/#quake_cli.result.QuakeResult","title":"QuakeResult  <code>module-attribute</code>","text":"<pre><code>QuakeResult = Result[QuakeResponse, str]\n</code></pre>"},{"location":"api/result/#quake_cli.result.FeatureResult","title":"FeatureResult  <code>module-attribute</code>","text":"<pre><code>FeatureResult = Result[QuakeFeature, str]\n</code></pre>"},{"location":"api/result/#quake_cli.result.DataResult","title":"DataResult  <code>module-attribute</code>","text":"<pre><code>DataResult = Result[dict, str]\n</code></pre>"},{"location":"api/result/#functional-error-handling","title":"Functional Error Handling","text":"<p>The quake-cli package uses Result types throughout for composable, functional error handling:</p> <pre><code>from quake_cli.result import handle_api_error\n\n# Convert exceptions to Result types\ntry:\n    # Some operation that might fail\n    data = risky_operation()\nexcept Exception as e:\n    result = handle_api_error(e)\n    # result is now a Result[T, str] that can be chained\n</code></pre>"},{"location":"api/result/#benefits","title":"Benefits","text":"<ul> <li>Composable: Chain operations without nested try/catch blocks</li> <li>Type Safe: Errors are part of the type signature</li> <li>Functional: Use map, then, and other combinators</li> <li>Explicit: Errors must be handled or explicitly ignored</li> </ul>"},{"location":"api/result/#integration-with-client","title":"Integration with Client","text":"<p>All client methods return Result types:</p> <pre><code>from quake_cli.client import GeoNetClient\n\nasync def example():\n    async with GeoNetClient() as client:\n        # Returns QuakeResult = Result[QuakeResponse, str]\n        result = await client.get_quakes()\n\n        # Chain operations functionally\n        processed = result.then(lambda response:\n            Ok(response.filter_by_magnitude(min_mag=4.0))\n        ).then(lambda filtered:\n            Ok(f\"Found {len(filtered)} large earthquakes\")\n        )\n\n        # Handle final result\n        match processed:\n            case Ok(message):\n                print(message)\n            case Err(error):\n                print(f\"Error: {error}\")\n</code></pre>"}]}